---
layout: post
title: "关联规则"
date: 2022-04-23
description: "关联规则"
tag: 机器学习
katex: true  
---

# 定义

事物之间存在关联，去发现这样的关联规则。啤酒与尿不湿的故事。

# 使用场景

1. 视频，音乐，图书等推荐：根据历史数据，如果大规模的存在某些用户听歌列表为：周杰伦、林宥嘉，则对于一个新用户来说，如果新用户听了周杰伦的歌单，马上给他推荐林宥嘉的，那他大概率也会听。

2. 风控策略自动挖掘：比如在贷后风控场景，根据历史经办催记，总结出规律，发现催记中包含 **抱怨、态度、剥离->投诉**，那后面遇到催记中含有这三个词语的，就需要采取主管或者客服安抚。再比如根据历史行为数据，发现了**沉默用户+非常用地登录+修改密码**->大概率都被盗号了，那一个新的账户满足这个三个条件，那马上就进行账户冻结或者实人认证，就能避免盗号风险的发生。

# 三个规则测量指标

以啤酒和尿不湿这个场景来解释这三个指标：

1. **支持度（Support）**

   商品组合出现的次数与总订单数的比值。

   | 订单编号 |             购买商品             |
   | :------: | :------------------------------: |
   |    1     |  牛奶、面包、尿不湿、啤酒、榴莲  |
   |    2     | 可乐、面包、尿不湿、啤酒、牛仔裤 |
   |    3     |  牛奶、尿不湿、啤酒、鸡蛋、咖啡  |
   |    4     |  牛奶、面包、尿不湿、啤酒、睡衣  |
   |    5     |  牛奶、面包、尿不湿、可乐、鸡翅  |

   比如：Support(牛奶 -> 面包) = 牛奶和面包共同出现的次数 / 总的订单数 = 3 / 5 = 0.6

2. **置信度(Confidence)**

   当你购买了A商品，会有多大概率购买B商品。本质上是个条件概率：在包含A的子集中，B的支持度。

   Confidence(牛奶 -> 啤酒) = 3 / 4 = 0.75，代表购买牛奶的订单当中，有多少订单买了啤酒。

   光有支持度和置信度还不够，比如Support{A} = 45%，Confidence{X} ->{A} = 20%，在大盘里面A随机出现已经是45%，X -> A才20%，随机比规则还好，所以这条规则不行，会使用Lift来解决这个问题。

3. **提升度(Lift)**

   我们在做商品推荐或者风控策略的时候，重点考虑的是提升度，因为提升度代表的是A 的出现，对B的出现概率提升的程度。

   Lift(A -> B) = Confidence(A -> B) / Support(B)

   所以会出现3种情况：

   - Lift(A -> B) > 1：代表有提升；
   - Lift(A -> B) = 1：代表没有提升也没有下降；
   - Lift(A -> B) < 1：代表有下降。

   Lift(啤酒→尿不湿) =Confidence (啤酒→尿不湿) / Support (尿不湿) = 1.0 / 0.8 = 1.25，可见啤酒对尿不湿是有提升的，提升度为1.25，大于1。

   **可以简单理解为：在全集的情况下，尿不湿的概率为80%，而在包含啤酒这个子集中，尿不湿的概率为100%，因此，子集的限定，提高了尿不湿的概率，啤酒的出现，提高了尿不湿的概率。**

# Apriori 算法

频繁项集(Frequent itemset) : 支持度大于最小支持度的项集。项集可以是单个商品也可以是组合。

频繁项集的子集必定为频繁项集：{Milk, Bread, Coke} 是频繁的 → {Milk, Coke} 是频繁的

非频繁项集的超级必定为非频繁项集：{Battery} 是非频繁的 → {Milk, Battery} 也非平凡

引入这个概念主要是为了减少无效计算。

# Python实现

```python
#包安装 我们使用efficient-apriori，python中也可以利用apyori库和mlxtend库
pip install efficient-apriori

from efficient-apriori import apriori

'''
apriori(transactions: typing.Iterable[typing.Union[set, tuple, list]], 
        min_support: float=0.5, 
        min_confidence: float=0.5, 
        max_length: int=8, 
        verbosity: int=0, 
        output_transaction_ids: bool=False)
上面就是这个函数的参数
min_support：最小支持度
min_confidence：最小置信度
max_length：项集长度 max_length=2,每个项集的最大长度为2
'''

# 构造数据集
data = [('牛奶','面包','尿不湿','啤酒','榴莲'),
        ('可乐','面包','尿不湿','啤酒','牛仔裤'),
        ('牛奶','尿不湿','啤酒','鸡蛋','咖啡'),
        ('面包','牛奶','尿不湿','啤酒','睡衣'),
        ('面包','牛奶','尿不湿','可乐','鸡翅')]
#挖掘频繁项集和频繁规则
itemsets, rules = apriori(data, min_support=0.6,  min_confidence=1)
#频繁项集
print(itemsets)

'''
{1: {('啤酒',): 4, ('尿不湿',): 5, ('牛奶',): 4, ('面包',): 4}, 
2: {('啤酒', '尿不湿'): 4, ('啤酒', '牛奶'): 3, ('啤酒', '面包'): 3, ('尿不湿', '牛奶'): 4, ('尿不湿', '面包'): 4, ('牛奶', '面包'): 3}, 
3: {('啤酒', '尿不湿', '牛奶'): 3, ('啤酒', '尿不湿', '面包'): 3, ('尿不湿', '牛奶', '面包'): 3}}
'''
itemsets[1] #满足条件的一元组合

'''
{('啤酒',): 4, ('尿不湿',): 5, ('牛奶',): 4, ('面包',): 4}
'''

print(rules)
'''
[{啤酒} -> {尿不湿}, {牛奶} -> {尿不湿}, 
{面包} -> {尿不湿}, {啤酒, 牛奶} -> {尿不湿}, 
{啤酒, 面包} -> {尿不湿}, {牛奶, 面包} -> {尿不湿}]
'''


```






